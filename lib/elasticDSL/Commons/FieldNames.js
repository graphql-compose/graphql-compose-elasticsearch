"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStringFields = getStringFields;
exports.getStringAsFieldConfigMap = getStringAsFieldConfigMap;
exports.getAnalyzedFields = getAnalyzedFields;
exports.getAnalyzedAsFieldConfigMap = getAnalyzedAsFieldConfigMap;
exports.getKeywordAsFieldConfigMap = getKeywordAsFieldConfigMap;
exports.getNumericFields = getNumericFields;
exports.getDateFields = getDateFields;
exports.getBooleanFields = getBooleanFields;
exports.getGeoPointFields = getGeoPointFields;
exports.getGeoPointAsFieldConfigMap = getGeoPointAsFieldConfigMap;
exports.getGeoShapeAsFieldConfigMap = getGeoShapeAsFieldConfigMap;
exports.getNestedFields = getNestedFields;
exports.getIpFields = getIpFields;
exports.getPercolatorFields = getPercolatorFields;
exports.getTermFields = getTermFields;
exports.getAllFields = getAllFields;
exports.getAllAsFieldConfigMap = getAllAsFieldConfigMap;
exports.getFieldNamesByElasticType = getFieldNamesByElasticType;
exports.getFieldNamesType = getFieldNamesType;
exports.getFieldConfigMap = getFieldConfigMap;

var _graphqlCompose = require("graphql-compose");

var _utils = require("../../utils");

/* eslint-disable no-param-reassign */
function getStringFields(opts) {
  return getFieldNamesType(opts, ['text', 'keyword', 'string'], 'String');
}

function getStringAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['text', 'keyword', 'string'], fc);
}

function getAnalyzedFields(opts) {
  return getFieldNamesType(opts, ['text', 'string'], 'String', true);
}

function getAnalyzedAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['text', 'string'], fc, true);
}

function getKeywordAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['keyword'], fc);
}

function getNumericFields(opts) {
  return getFieldNamesType(opts, ['byte', 'short', 'integer', 'long', 'double', 'float', 'half_float', 'scaled_float', 'token_count'], 'Numeric');
}

function getDateFields(opts) {
  return getFieldNamesType(opts, ['date'], 'Date');
}

function getBooleanFields(opts) {
  return getFieldNamesType(opts, ['boolean'], 'Boolean');
}

function getGeoPointFields(opts) {
  return getFieldNamesType(opts, ['geo_point'], 'GeoPoint');
}

function getGeoPointAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['geo_point'], fc);
}

function getGeoShapeAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['geo_shape'], fc);
}

function getNestedFields(opts) {
  return getFieldNamesType(opts, ['nested'], 'Nested');
}

function getIpFields(opts) {
  return getFieldNamesType(opts, ['ip'], 'Ip');
}

function getPercolatorFields(opts) {
  return getFieldNamesType(opts, ['percolator'], 'Percolator');
}

function getTermFields(opts) {
  return getFieldNamesType(opts, ['keyword', 'date', 'boolean', 'ip', 'byte', 'short', 'integer', 'long', 'double', 'float', 'half_float', 'scaled_float', 'token_count'], 'Term');
}

function getAllFields(opts) {
  return getFieldNamesType(opts, ['_all'], 'All');
}

function getAllAsFieldConfigMap(opts, fc) {
  return getFieldConfigMap(opts, ['_all'], fc);
}

function getFieldNamesByElasticType(fieldMap, types) {
  const fieldNames = [];
  types.forEach(type => {
    if (typeof fieldMap[type] === 'object') {
      Object.keys(fieldMap[type]).forEach(fieldName => {
        fieldNames.push(fieldName);
      });
    }
  });
  return fieldNames;
}

function getFieldNamesType(opts, types, typePrefix, addAll = false) {
  if (!opts || !opts.fieldMap) {
    return 'String';
  }

  if (!types) {
    types = ['_all'];
    typePrefix = 'All';
  }

  if (!typePrefix) {
    types.sort();
    typePrefix = types.map(t => (0, _graphqlCompose.upperFirst)(t)).join('');
  }

  const name = (0, _utils.getTypeName)(`${typePrefix}Fields`, opts);
  const description = (0, _utils.desc)(`Avaliable fields from mapping.`);
  return (0, _utils.getOrSetType)(name, () => {
    if (!opts || !opts.fieldMap) {
      return 'String';
    }

    const values = getEnumValues(opts.fieldMap, types, addAll);

    if (Object.keys(values).length === 0) {
      return 'String';
    }

    return _graphqlCompose.EnumTypeComposer.create({
      name,
      description,
      values
    });
  });
}

function getEnumValues(fieldMap, types, addAll = false) {
  const values = {};

  if (addAll) {
    values._all = {
      value: '_all'
    };
  }

  getFieldNamesByElasticType(fieldMap, types).forEach(fieldName => {
    values[fieldName] = {
      value: fieldName.replace(/__/g, '.')
    };
  });
  return values;
} // FieldsMap generated by this function, contain underscored field names
// So you should manually reassemble args before sending query to ElasticSearch
// for renaming { "field__subFild": 123 } to { "field.subField": 123 }
// Eg. see elasticDSL/Query/Query.js method prepareQueryInResolve()


function getFieldConfigMap(opts, types, fc, addAll = false) {
  if (!fc) fc = 'JSON';

  if (!opts || !opts.fieldMap) {
    return 'JSON';
  }

  if (!types) {
    types = ['_all'];
  }

  const fcMap = {};

  if (addAll) {
    fcMap._all = fc;
  }

  getFieldNamesByElasticType(opts.fieldMap, types).forEach(fieldName => {
    fcMap[fieldName] = fc;
  });

  if (Object.keys(fcMap).length === 0) {
    return 'JSON';
  }

  return fcMap;
}