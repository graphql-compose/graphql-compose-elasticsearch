// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Elastic DSL Query should match 1`] = `
"schema {
  query: RootQuery
}

# Elasticsearch provides a full Query DSL based on JSON to define queries. [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html) 
input Elastic_Query_50 {
  match_all: Elastic_QueryMatchAll_50
  bool: Elastic_QueryBool_50
  constant_score: Elastic_QueryConstantScore_50
  dis_max: Elastic_QueryDisMax_50
  boosting: Elastic_QueryBoosting_50
  function_score: Elastic_QueryFunctionScore_50

  # Match Query accept text/numerics/dates, analyzes them, and constructs a query. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html) 
  match: JSON

  # The match_phrase query analyzes the text and creates a phrase query out of the analyzed text. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html) 
  match_phrase: JSON

  # The match_phrase_prefix is the same as match_phrase, except that it allows for
  # prefix matches on the last term in the text. Eg \\"quick brown f\\" [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html) 
  match_phrase_prefix: JSON
  multi_match: Elastic_QueryMultiMatch_50

  # The common terms query is a modern alternative to stopwords which improves the
  # precision and recall of search results (by taking stopwords into account),
  # without sacrificing performance. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html) 
  common: JSON
  query_string: Elastic_QueryQueryString_50
  simple_query_string: Elastic_QuerySimpleQueryString_50

  # Returns documents that have at least one non-null value in the original field. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html) 
  exists: JSON

  # The fuzzy query uses similarity based on Levenshtein edit distance. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html) 
  fuzzy: JSON

  # Filters documents that only have the provided ids. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-ids-query.html) 
  ids: JSON

  # Matches documents that have fields containing terms with a specified prefix
  # (not analyzed). [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html) 
  prefix: JSON

  # Matches documents with fields that have terms within a certain range. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html) 
  range: JSON

  # The regexp query allows you to use regular expression term queries. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html) 
  regexp: JSON

  # Filters documents matching the provided document / mapping type. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-type-query.html) 
  type: JSON

  # Find documents which contain the exact term specified in the field specified.
  # { fieldName: value } or { fieldName: { value: value, boost: 2.0 } } [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html) 
  term: JSON

  # Filters documents that have fields that match any of the provided terms (not
  # analyzed). { fieldName: [values] } [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html) 
  terms: JSON

  # Matches documents that have fields matching a wildcard expression (not
  # analyzed). Supported wildcards are *, which matches any character sequence
  # (including the empty one), and ?, which matches any single character. Note
  # that this query can be slow, as it needs to iterate over many terms. In order
  # to prevent extremely slow wildcard queries, a wildcard term should not start
  # with one of the wildcards * or ?. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html) 
  wildcard: JSON

  # A query allowing to filter hits based on a point location using a bounding
  # box. Requires the geo_point Mapping. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-bounding-box-query.html) 
  geo_bounding_box: JSON

  # Filters documents that include only hits that exists within a specific
  # distance from a geo point.  Requires the geo_point Mapping. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-distance-query.html) 
  geo_distance: JSON

  # A query allowing to include hits that only fall within a polygon of points.
  # Requires the geo_point Mapping. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-polygon-query.html) 
  geo_polygon: JSON

  # Filter documents indexed using the geo_shape type. Requires the geo_shape Mapping. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-shape-query.html) 
  geo_shape: JSON
  more_like_this: Elastic_QueryMoreLikeThis_50
  percolate: Elastic_QueryPercolate_50
  script: Elastic_QueryScript_50
  has_child: Elastic_QueryHasChild_50
  has_parent: Elastic_QueryHasParent_50
  nested: Elastic_QueryNested_50
  parent_id: Elastic_QueryParentId_50
}

# A query that matches documents matching boolean combinations of other queries.
# The bool query maps to Lucene BooleanQuery. It is built using one or more
# boolean clauses, each clause with a typed occurrence. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) 
input Elastic_QueryBool_50 {
  # The clause (query) must appear in matching documents and will contribute to the score. 
  must: Elastic_Query_50

  # The clause (query) must appear in matching documents. However unlike must the
  # score of the query will be ignored. Filter clauses are executed in filter
  # context, meaning that scoring is ignored and clauses are considered for caching. 
  filter: Elastic_Query_50

  # The clause (query) should appear in the matching document. In a boolean query
  # with no must or filter clauses, one or more should clauses must match a
  # document. The minimum number of should clauses to match can be set using the
  # minimum_should_match parameter. 
  should: Elastic_Query_50

  # The minimum number of should clauses to match can be set using the minimum_should_match parameter. 
  minimum_should_match: Int

  # The clause (query) must not appear in the matching documents. Clauses are
  # executed in filter context meaning that scoring is ignored and clauses are
  # considered for caching. Because scoring is ignored, a score of 0 for all
  # documents is returned. 
  must_not: Elastic_Query_50
  boost: Float
}

# The boosting query can be used to effectively demote results that match a given query. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html) 
input Elastic_QueryBoosting_50 {
  positive: Elastic_Query_50
  negative: Elastic_Query_50
  negative_boost: Float
}

# A query that wraps another query and simply returns a constant score equal to
# the query boost for every document in the filter. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html) 
input Elastic_QueryConstantScore_50 {
  filter: Elastic_Query_50!
  boost: Float!
}

# A query that generates the union of documents produced by its subqueries, and
# that scores each document with the maximum score for that document as produced
# by any subquery, plus a tie breaking increment for any additional matching subqueries. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-dis-max-query.html) 
input Elastic_QueryDisMax_50 {
  queries: [Elastic_Query_50]
  boost: Float
  tie_breaker: Float
}

# The function_score allows you to modify the score of documents that are
# retrieved by a query. This can be useful if, for example, a score function is
# computationally expensive and it is sufficient to compute the score on a
# filtered set of documents. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html) 
input Elastic_QueryFunctionScore_50 {
  query: Elastic_Query_50
  boost: String

  # Can be: \`multiply\`, \`replace\`, \`sum\`, \`avg\`, \`max\`, \`min\`.
  boost_mode: String
  random_score: Elastic_QueryFunctionScoreRandom_50
  functions: [Elastic_QueryFunctionScoreFunction_50]
  max_boost: Float

  # Can be: \`multiply\`, \`sum\`, \`avg\`, \`first\`, \`max\`, \`min\`.
  score_mode: String
  min_score: Float
}

input Elastic_QueryFunctionScoreFunction_50 {
  filter: Elastic_Query_50
  random_score: Elastic_QueryFunctionScoreRandom_50
  weight: Float
  script_score: JSON
  field_value_factor: JSON
  gauss: JSON
  linear: JSON
  exp: JSON
}

input Elastic_QueryFunctionScoreRandom_50 {
  seed: Float
}

# The has_child filter accepts a query and the child type to run against, and
# results in parent documents that have child docs matching the query. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-child-query.html) 
input Elastic_QueryHasChild_50 {
  type: String
  query: Elastic_Query_50

  # Can be: \`avg\`, \`sum\`, \`max\`, \`min\`, \`none\`.
  score_mode: String
  min_children: Int
  max_children: Int
}

# The has_parent query accepts a query and a parent type. The query is executed in
# the parent document space, which is specified by the parent type [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-parent-query.html) 
input Elastic_QueryHasParent_50 {
  parent_type: String
  query: Elastic_Query_50
  score: Boolean
  ignore_unmapped: Boolean
}

# The most simple query, which matches all documents, giving them all a _score of 1.0. 
input Elastic_QueryMatchAll_50 {
  boost: Float
}

# The More Like This Query (MLT Query) finds documents that are \\"like\\" a given set of documents. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html) 
input Elastic_QueryMoreLikeThis_50 {
  fields: [String]
  like: JSON
  unlike: JSON
  min_term_freq: Int
  max_query_terms: Int
  boost: Float
}

# The multi_match query builds on the match query to allow multi-field queries. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html) 
input Elastic_QueryMultiMatch_50 {
  query: String!

  # Array of fields [ \\"title\\", \\"*_name\\", \\"subject^3\\" ]. You may use wildcards and boosting field. 
  fields: [String]!
  type: Elastic_QueryMultiMatchTypeEnum_50
  operator: Elastic_QueryMultiMatchOperatorEnum_50
  minimum_should_match: String
  analyzer: String
}

enum Elastic_QueryMultiMatchOperatorEnum_50 {
  and
  or
}

enum Elastic_QueryMultiMatchTypeEnum_50 {
  best_fields
  most_fields
  cross_fields
  phrase
  phrase_prefix
}

# Nested query allows to query nested objects / docs. The query is executed
# against the nested objects / docs as if they were indexed as separate docs. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html) 
input Elastic_QueryNested_50 {
  path: String

  # Can be: \`avg\`, \`sum\`, \`max\`, \`min\`, \`none\`.
  score_mode: String
  query: Elastic_Query_50
}

# The parent_id query can be used to find child documents which belong to a
# particular parent. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-parent-id-query.html) 
input Elastic_QueryParentId_50 {
  type: String
  id: String
  ignore_unmapped: Boolean
}

# The percolate query can be used to match queries stored in an index. The
# percolate query itself contains the document that will be used as query to match
# with the stored queries. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html) 
input Elastic_QueryPercolate_50 {
  field: String!
  document_type: String!
  document: JSON!
}

# A query that uses a query parser in order to parse its content. Eg. \\"this AND
# that OR thus\\" or \\"(content:this OR name:this) AND (content:that OR name:that)\\" [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html) 
input Elastic_QueryQueryString_50 {
  query: String!
  fields: [String]
  default_field: String
  default_operator: Elastic_QueryQueryStringOperatorEnum_50
  analyzer: String
  allow_leading_wildcard: Boolean
  enable_position_increments: Boolean
  fuzzy_max_expansions: Int
  fuzziness: String
  fuzzy_prefix_length: Int
  phrase_slop: Int
  boost: Float
  auto_generate_phrase_queries: Boolean
  analyze_wildcard: Boolean
  max_determinized_states: Int
  minimum_should_match: String
  lenient: Boolean
  time_zone: String
  quote_field_suffix: String
  split_on_whitespace: Boolean
  use_dis_max: Boolean
  tie_breaker: Int
}

enum Elastic_QueryQueryStringOperatorEnum_50 {
  and
  or
}

# A query allowing to define scripts as queries. They are typically used in a
# filter context. [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-query.html) 
input Elastic_QueryScript_50 {
  script: Elastic_QueryScriptScript_50
}

input Elastic_QueryScriptScript_50 {
  inline: String!
  lang: String!
  params: JSON
}

# A query that uses the SimpleQueryParser to parse its context. Unlike the regular
# query_string query, the simple_query_string query will never throw an exception,
# and discards invalid parts of the query. Eg. \\"this AND that OR thus\\" or
# \\"(content:this OR name:this) AND (content:that OR name:that)\\" [Documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html) 
input Elastic_QuerySimpleQueryString_50 {
  query: String!
  fields: [String]
  default_operator: Elastic_QuerySimpleQueryStringOperatorEnum_50
  analyzer: String

  # Can provided several flags, eg \\"OR|AND|PREFIX\\". The available flags are: ALL,
  # NONE, AND, OR, NOT, PREFIX, PHRASE, PRECEDENCE, ESCAPE, WHITESPACE, FUZZY,
  # NEAR, and SLOP. 
  flags: String
  analyze_wildcard: Boolean
  lenient: Boolean
  minimum_should_match: String
  quote_field_suffix: String
}

enum Elastic_QuerySimpleQueryStringOperatorEnum_50 {
  and
  or
}

# The \`JSON\` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
scalar JSON

type RootQuery {
  search(body: Elastic_Query_50): Int
}
"
`;
